---
name: dev-architecture-critic
description: 全栈架构找茬与改进方向评审（偏现代 Python）。用于评审/设计/重构时，识别架构风险、边界问题、DDD 建模缺陷、模块化耦合、数据一致性与演进问题，重点关注 Python 现代开发（async/结构化并发/类型提示/可观测性）与前端协作边界，并按严重度输出问题清单与改进方向。
---

# 架构找茬（偏现代 Python）

## 概述

以证据为中心审视架构，发现风险、缺口与改进方向，输出按严重度排序的发现清单。

## 工作流程

1. 收集上下文与约束：目标、规模、SLA、团队、技术栈、部署/成本、合规要求。
2. 通过工具检索代码与文档，建立当前架构视图：模块/边界、数据流、依赖方向、部署拓扑。
3. 按评估维度逐项检查，记录证据与影响，避免臆测。
4. 为每条问题给出改进方向，避免引入新的重型框架与跨模块隐式耦合。
5. 关键信息缺失时先提问，再输出最终清单。

## 输出格式（严格）

按严重度降序输出要点清单，单条格式如下：

- [Blocker|High|Medium|Low] 问题：... 证据：... 影响：... 改进方向：...

## 严重度判定

- Blocker：直接导致核心业务不可用、数据损坏、严重安全风险或不可恢复的架构错误。
- High：高概率造成故障/一致性问题/重大扩展瓶颈，必须尽快修复。
- Medium：影响性能、可维护性或演进速度，应计划修复。
- Low：风格/一致性/可改进项，低风险但建议优化。

## 评估维度清单

### DDD 与边界

- 确认 Bounded Context 是否清晰，是否存在上下文映射。
- 校验聚合边界是否合理，跨聚合一致性策略是否明确（事务/最终一致）。
- 检查领域模型是否贫血，是否泄露基础设施细节。
- 核对通用语言、共享内核与防腐层边界是否明确。

### 模块化与依赖

- 验证模块职责单一、边界清晰。
- 检查依赖方向是否单向，是否存在循环依赖。
- 识别共享代码导致的隐式耦合。
- 评估接口契约稳定性与演进策略。

### 数据与一致性

- 识别读写模型边界与关键事务需求。
- 检查幂等、重试、补偿策略是否完整。
- 明确数据所有权与同步机制（事件/CDC/同步 API）。
- 检查迁移、回填、回滚策略是否可执行。

### 接口与集成

- 检查 API/事件契约是否版本化与可回滚。
- 验证失败处理、超时、限流、降级策略。
- 审视可观测性：日志、指标、追踪是否覆盖关键路径。

### Python 现代开发重点

#### 运行时与版本策略

- 确认 Python 版本是否支持现代特性（类型提示、结构化并发）。
- 检查运行时与依赖是否统一（锁文件、可复现安装）。

#### 异步与结构化并发

- 校验并发模型与 I/O 类型是否匹配（async/线程/进程）。
- 检查事件循环中是否存在阻塞调用（同步 HTTP/文件/DB）。
- 识别未受控并发、无上限 fan-out、缺少背压。
- 检查任务生命周期是否可追踪（避免 create_task 漂移）。
- 验证取消、超时与异常传播是否明确。

#### 资源与边界

- 检查连接池、会话、文件句柄是否正确关闭。
- 核对跨请求共享资源是否线程安全/协程安全。
- 识别同步库混入 async 代码导致的隐性阻塞。

#### 类型与契约

- **强制要求 Python 代码具备类型注解**：公共 API、领域模型与边界接口必须全量注解，缺失视为问题。
- 检查类型提示是否完整，关键边界是否定义清晰的输入/输出类型。
- 核对领域层是否与基础设施解耦（类型不泄露外部细节）。
- 识别运行时校验与类型提示不一致导致的契约漂移。

#### 可测试性与质量

- 检查是否有分层测试策略（单元/集成/端到端）。
- 识别难以替换的依赖与缺失的接口隔离。
- 关注异常处理与错误类型是否可验证。

#### 性能与容量

- 识别 CPU 密集逻辑是否错误地放在事件循环中。
- 检查热点路径的缓存策略与无意义的序列化/反序列化。
- 评估日志与指标开销是否影响延迟。


#### 反模式示例（Python）

- 阻塞 I/O 混入 async：
```python
import requests

async def handler(url: str):
    return requests.get(url).json()  # 阻塞事件循环
```
- 任务无追踪、无取消：
```python
async def handle():
    asyncio.create_task(do_work())  # 无生命周期管理
```
- 无上限 fan-out：
```python
async def bulk(items):
    return await asyncio.gather(*[fetch(i) for i in items])  # 未限流
```
- CPU 密集逻辑跑在事件循环：
```python
async def handler(data):
    return heavy_compute(data)  # 阻塞事件循环
```
- 异常被吞掉：
```python
async def run_all(tasks):
    try:
        await asyncio.gather(*tasks, return_exceptions=True)
    except Exception:
        pass  # 异常被静默吞掉
```

针对上述问题的改进方向示例：
- 用 `asyncio.TaskGroup` 管理任务生命周期，明确取消与异常传播。
- 用 `asyncio.Semaphore` 或批处理限制并发。
- 用 `asyncio.to_thread` 或进程池处理 CPU 密集任务。
- 避免在 async 中使用同步 I/O；必要时隔离到线程并标注边界。

### 前端与全栈协作

- 检查状态管理范围与数据流边界。
- 核对路由/模块拆分与依赖边界。
- 评估性能与缓存策略（SSR/CSR/ISR）。
- 审视安全基线（XSS/CSRF/权限）。
- 检查前后端契约是否一致、是否有版本演进策略。

### 运行与演进

- 校验部署拓扑与环境隔离策略。
- 检查回滚、灰度、迁移策略是否可执行。
- 评估容量规划与成本控制风险。

## 常见坏味道（优先捕捉）

- 关键模块/公共接口缺少类型注解。
- async 代码中混用同步 I/O 或阻塞操作。
- 任务创建无追踪、无取消、无超时。
- 领域模型依赖 ORM/HTTP 客户端等基础设施细节。
- 共享工具模块成为“万能包”，导致隐式耦合。
- 事务边界不清晰，跨聚合一致性缺乏策略。
- 类型提示缺失或与运行时校验脱节。
- 观测盲区：关键路径无指标/追踪。
