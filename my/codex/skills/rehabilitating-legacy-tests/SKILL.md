---
name: rehabilitating-legacy-tests
description: 使用于接手遗留 Python 项目且测试大量失败/很慢/缺失，需要把测试体系改造成符合 TDD 规范并使用 pytest 时使用
---

# 遗留测试改造为 TDD（pytest）

## 概述

把“历史项目的不可控测试”变成“可验证、可演进”的 TDD 工作流。

**必需子技能：** 使用 test-driven-development

核心目标：在不破坏现有系统的前提下，建立一个“可信测试窗口”，并逐步把测试行为对齐到 TDD。

## 使用时机

- 大量红测或测试完全缺失
- 测试非常慢、依赖外部服务或数据库
- 项目强耦合、难以直接测试
- 新增功能或修 bug 需要“先补测试再实现”

**不要用于：**
- 一次性原型或临时脚本
- 已经有稳定、快速、清晰的测试体系

## 决策流程（ASCII）

```
Start
  |
  |-- Suite 绿？ ----------------------- Yes --> 走标准 TDD
  |                                     (RED->GREEN->REFACTOR)
  |
  No (Suite 红)
  |
  |-- 是否已有针对当前行为的失败测试？ -- Yes --> 修复它并最小实现
  |                                     (只跑可信子集)
  |
  No
  |
  |-- 先写失败测试（锁定行为） --> 仅跑目标测试 + 必要依赖
  |
  +--> 记录红测/慢测为技术债清单
```

## 核心模式

### 1) 建立“可信测试窗口”

在全局红测下，定义**可信子集**：
- 只包含与当前行为相关的测试
- 可稳定、快速运行
- 结果可解释

**原则：** 可信子集必须先失败再变绿，否则不是 TDD。

### 2) 先行为后实现

任何修复或新增功能，都必须：
1. 写失败测试（pytest）
2. `uv run pytest <目标测试>` 观察失败
3. 写最小实现
4. `uv run pytest <目标测试>` 观察通过

### 3) 依赖外部系统时先隔离，再回归

对慢/外部依赖的测试，优先：
- 收敛为“最小可运行替身”（in-memory、容器化 stub）
- 明确分层：fast / slow / integration
- 允许慢测进入夜间或独立流水线，但必须保留

### 4) 逐步清洗，而非“一次性重写”

每次修改只清理与你的行为相关的路径。
不要试图一次性修复所有红测。

## 快速参考

| 场景 | 做法 | 产出 |
|------|------|------|
| 全局红测 | 建立可信子集 | 可验证的 TDD 窗口 |
| 测试太慢 | 分层 + 替身 | fast/slow/integration 标签 |
| 没有测试 | 先写失败测试 | 行为锁定 |
| 强耦合 | 用外层测试包住 | 最小回归保护 |

## 实现（推荐步骤）

1) **创建测试地图**
   - 统计测试目录、运行时长、外部依赖
   - 标记：`slow`、`integration`、`legacy`

2) **建立可信子集**
   - 选择与当前改动相关的测试
   - 如果不存在，先写失败测试

3) **跑 RED**
   - `uv run pytest tests/path::test_name`
   - 确认是“行为缺失”导致失败，而非拼写或环境问题

4) **写最小实现**
   - 仅满足测试
   - 禁止顺手重构

5) **跑 GREEN**
   - 同一路径复跑，确保通过

6) **记录技术债**
   - 未修的红测、慢测写清单
   - 每次只偿还与当前改动强相关的债

## 例子（pytest）

```python
def test_rejects_blank_email(client):
    resp = client.post("/signup", json={"email": ""})
    assert resp.status_code == 400
    assert resp.json()["error"] == "email_required"
```

运行失败：
```bash
uv run pytest tests/test_signup.py::test_rejects_blank_email
```

最小实现后再跑同一条测试，确保变绿。

## 常见错误

- 先改生产代码，再补测试
- 只改测试让它通过（而不是修行为）
- 为了速度删掉慢测（而不是分层）
- 过度 mock，测的是 mock 行为

## 合理化借口 → 现实

| 借口 | 现实 |
|------|------|
| “CI 只剩 1 小时，先修代码吧” | 没有失败测试就不是 TDD |
| “全红测太多，先绕过” | 可信子集也必须 RED |
| “慢测先删，之后补” | 删除 = 丢失保护 |
| “先加一堆 mock” | mock 不是行为 |

## 红旗 - 停止并重新开始

- 没有失败测试就写实现
- 测试立即通过
- 用修改测试代替修复行为
- 因为“太慢”而直接删测试

**出现红旗 = 删除实现，用 TDD 重新开始。**

