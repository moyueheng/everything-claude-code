---
name: writing-skills
description: 创建新技能、编辑现有技能或部署前验证技能是否有效时使用
metadata:
  short-description: 编写技能文档的测试驱动方法
---

# 编写技能 (Writing Skills)

## 概述

**编写技能就是测试驱动开发（TDD）在过程文档上的应用。**

**个人技能存放在特定目录：**
- Codex: `~/.codex/skills/`
- Claude Code: `~/.claude/skills/`

你编写测试用例（使用子代理的压力场景），观察它们失败（基线行为），编写技能（文档），观察测试通过（代理遵循规范），然后重构（关闭漏洞）。

**核心原则：** 如果你没有观察到Agent在没有Skill时的失败行为，你就不知道技能是否教授了正确的内容。

**必备背景：** 使用此技能前必须理解 `test-driven-development` skill。该 skill 定义了基本的 RED-GREEN-REFACTOR 循环。本 skill 将 TDD 适配到文档编写。

## 什么是技能？

**技能**是经过验证的技术、模式或工具的参考指南。技能帮助未来的 Claude 实例找到并应用有效的方法。

**技能是：** 可重用的技术、模式、工具、参考指南

**技能不是：** 叙述你如何一次解决某个问题的故事

## 技能创建的 TDD 映射

| TDD 概念 | 技能创建 |
|----------|----------|
| **测试用例** | 使用子代理的压力场景 |
| **生产代码** | 技能文档 (SKILL.md) |
| **测试失败 (RED)** | 没有技能时代理违反规则（基线） |
| **测试通过 (GREEN)** | 有技能时代代遵循规范 |
| **重构** | 在保持遵循的同时关闭漏洞 |
| **先写测试** | 在编写技能前运行基线场景 |
| **观察失败** | 记录代理使用的确切合理化借口 |
| **最小代码** | 编写针对那些特定违规的技能 |
| **观察通过** | 验证代理现在遵循规范 |
| **重构循环** | 找到新的合理化借口 → 堵塞 → 重新验证 |

整个技能创建过程遵循 RED-GREEN-REFACTOR。

## 何时创建技能

**创建时机：**
- 技术对你来说不是显而易见的
- 你会在多个项目中再次参考它
- 模式广泛适用（非项目特定）
- 其他人会受益

**不要创建：**
- 一次性解决方案
- 其他地方有完善文档的标准实践
- 项目特定约定（放在 CLAUDE.md/AGENTS.md 中）
- 机械约束（如果可以通过 regex/验证强制执行，就自动化——把文档留给需要判断的情况）

## 技能类型

### 技术
有步骤可遵循的具体方法（条件等待、根因追踪）

### 模式
思考问题的方式（标志展平、测试不变量）

### 参考
API 文档、语法指南、工具文档（办公文档）

## 目录结构

```
skills/
  skill-name/
    SKILL.md              # 主要参考（必需）
    supporting-file.*     # 仅在需要时
```

**扁平命名空间** - 所有技能在一个可搜索的命名空间中

**分离文件用于：**
1. **重型参考**（100+ 行）- API 文档、综合语法
2. **可重用工具** - 脚本、实用程序、模板

**保持内联：**
- 原则和概念
- 代码模式（< 50 行）
- 其他所有内容

## SKILL.md 结构

**Frontmatter (YAML)：**
- 仅支持两个字段：`name` 和 `description`
- 最多 1024 字符
- `name`：仅使用字母、数字和连字符（无括号、特殊字符）
- `description`：第三人称，仅描述何时使用（不描述它做什么）
  - 以 "Use when..." 或 "使用...时使用" 开头，专注于触发条件
  - 包含具体症状、情况和上下文
  - **永远不要总结技能的过程或工作流**（见 CSO 部分了解原因）
  - 尽可能保持在 500 字符以内

```markdown
---
name: skill-name-with-hyphens
description: 使用...时使用 [具体触发条件和症状]
---

# 技能名称

## 概述
这是什么？1-2 句话的核心原则。

## 使用时机
[如果决策不显而易见，使用小型内联流程图]

包含症状和用例的项目列表
何时不使用

## 核心模式（用于技术/模式）
前后代码对比

## 快速参考
表格或项目符号，用于扫描常见操作

## 实现
简单模式使用内联代码
重型参考或可重用工具链接到单独文件

## 常见错误
出错的地方 + 修复方法

## 实际影响（可选）
具体结果
```

## Claude 搜索优化 (CSO)

**对发现至关重要：** 未来的 Claude 需要找到你的技能

### 1. 丰富的描述字段

**目的：** Claude 读取描述来决定为给定任务加载哪些技能。让它回答："我现在应该阅读这个技能吗？"

**格式：** 以 "Use when..." 或 "使用...时使用" 开头，专注于触发条件

**关键：描述 = 使用时机，而非技能做什么**

描述应该仅描述触发条件。不要在描述中总结技能的过程或工作流。

**为何重要：** 测试发现，当描述总结技能的工作流时，Claude 可能会遵循描述而不是阅读完整的技能内容。一个描述说 "任务间进行代码审查" 导致 Claude 做了一次审查，即使技能的流程图清楚显示了两次审查（规范合规性然后代码质量）。

当描述改为仅 "使用...时使用在当前会话中执行具有独立任务的实现规划"（无工作流总结）时，Claude 正确阅读了流程图并遵循了两阶段审查流程。

**陷阱：** 总结工作流的描述创建了一条 Claude 会采取的捷径。技能主体变成了 Claude 跳过的文档。

```yaml
# ❌ 坏：总结工作流 - Claude 可能遵循此而不是阅读技能
description: 执行计划时使用 - 每个任务分派子代理，任务间进行代码审查

# ❌ 坏：太多过程细节
description: TDD 使用 - 先写测试，观察失败，写最小代码，重构

# ✅ 好：仅触发条件，无工作流总结
description: 使用...时使用在当前会话中执行具有独立任务的实现规划

# ✅ 好：仅触发条件
description: 实现任何功能或错误修复时，在编写实现代码之前使用
```

**内容：**
- 使用具体的触发器、症状和表明此技能适用的情况
- 描述*问题*（竞争条件、不一致行为），而非*语言特定症状*（setTimeout、sleep）
- 保持触发器与技术无关，除非技能本身是技术特定的
- 如果技能是技术特定的，在触发器中明确说明
- 用第三人称编写（注入到系统提示中）
- **永远不要总结技能的过程或工作流**

### 2. 关键词覆盖

使用 Claude 会搜索的词：
- 错误消息："Hook timed out"、"ENOTEMPTY"、"race condition"
- 症状："flaky"、"hanging"、"zombie"、"pollution"
- 同义词："timeout/hang/freeze"、"cleanup/teardown/afterEach"
- 工具：实际命令、库名、文件类型

### 3. 描述性命名

**使用主动语态，动词优先：**
- ✅ `creating-skills` 而非 `skill-creation`
- ✅ `condition-based-waiting` 而非 `async-test-helpers`

### 4. Token 效率（关键）

**问题：** getting-started 和频繁引用的技能加载到每个对话中。每个 token 都很重要。

**目标字数：**
- 入门工作流：每个 <150 字
- 频繁加载的技能：总共 <200 字
- 其他技能：<500 字（仍然简洁）

**技术：**

**将细节移到工具帮助：**
```bash
# ❌ 坏：在 SKILL.md 中记录所有标志
search-conversations 支持 --text、--both、--after DATE、--before DATE、--limit N

# ✅ 好：引用 --help
search-conversations 支持多种模式和过滤器。运行 --help 查看详细信息。
```

**使用交叉引用：**
```markdown
# ❌ 坏：重复工作流细节
搜索时，使用模板分派子代理...
[20 行重复指令]

# ✅ 好：引用其他技能
始终使用子代理（节省 50-100x 上下文）。必需：使用 [other-skill-name] 进行工作流。
```

**压缩示例：**
```markdown
# ❌ 坏：冗长的示例（42 字）
your human partner: "我们之前是如何处理 React Router 中的身份验证错误的？"
You: 我将搜索过去的对话以查找 React Router 身份验证模式。
[使用搜索查询分派子代理："React Router authentication error handling 401"]

# ✅ 好：最小示例（20 字）
Partner: "我们之前如何处理 React Router 中的身份验证错误？"
You: 搜索中...
[分派子代理 → 综合]
```

**消除冗余：**
- 不要重复交叉引用技能中的内容
- 不要解释从命令中显而易见的内容
- 不要包含同一模式的多个示例

**验证：**
```bash
wc -w skills/path/SKILL.md
# 入门工作流：目标是每个 <150
# 其他频繁加载：总共 <200
```

**根据你做什么或核心洞察来命名：**
- ✅ `condition-based-waiting` > `async-test-helpers`
- ✅ `using-skills` 而非 `skill-usage`
- ✅ `flatten-with-flags` > `data-structure-refactoring`
- ✅ `root-cause-tracing` > `debugging-techniques`

**动名词（-ing）适用于过程：**
- `creating-skills`、`testing-skills`、`debugging-with-logs`
- 主动，描述你正在采取的行动

### 5. 交叉引用其他技能

**编写引用其他技能的文档时：**

仅使用技能名称，带有显式需求标记：
- ✅ 好：`**必需子技能：** 使用 test-driven-development`
- ✅ 好：`**必需背景：** 你必须理解 systematic-debugging`
- ❌ 坏：`见 skills/testing/test-driven-development`（不清楚是否需要）
- ❌ 坏：`@skills/testing/test-driven-development/SKILL.md`（强制加载，消耗上下文）

**为何不用 @ 链接：** `@` 语法立即强制加载文件，在需要之前消耗 200k+ 上下文。

## 流程图使用

**仅对以下情况使用流程图：**
- 不明显的决策点
- 你可能过早停止的过程循环
- "何时使用 A vs B" 决策

**切勿对以下情况使用流程图：**
- 参考材料 → 表格、列表
- 代码示例 → Markdown 代码块
- 线性指令 → 编号列表
- 没有语义意义的标签（step1、helper2）

## 代码示例

**一个优秀的示例胜过许多平庸的示例**

选择最相关的语言：
- 测试技术 → TypeScript/JavaScript
- 系统调试 → Shell/Python
- 数据处理 → Python

**好的示例：**
- 完整且可运行
- 注释良好解释原因
- 来自真实场景
- 清楚显示模式
- 准备好调整（不是通用模板）

**不要：**
- 用 5+ 种语言实现
- 创建填空模板
- 编写人为示例

你很擅长移植——一个优秀的示例就足够了。

## 文件组织

### 自包含技能
```
defense-in-depth/
  SKILL.md    # 所有内容内联
```
何时：所有内容适合，不需要重型参考

### 带可重用工具的技能
```
condition-based-waiting/
  SKILL.md    # 概述 + 模式
  example.ts  # 可调整的工作辅助工具
```
何时：工具是可重用代码，而不仅仅是叙述

### 带重型参考的技能
```
pptx/
  SKILL.md       # 概述 + 工作流
  pptxgenjs.md   # 600 行 API 参考
  ooxml.md       # 500 行 XML 结构
  scripts/       # 可执行工具
```
何时：参考材料太大无法内联

## 铁律（与 TDD 相同）

```
没有失败的测试就写不出技能
```

这适用于新技能和现有技能的编辑。

先写技能后测试？删除它。重新开始。
无测试编辑技能？同样的违规。

**无例外：**
- 不是"简单的添加"
- 不是"只是添加一部分"
- 不是"文档更新"
- 不要保留未经测试的更改作为"参考"
- 不要在运行测试时"适应"
- 删除意味着删除

## 测试所有技能类型

不同的技能类型需要不同的测试方法：

### 纪律强制技能（规则/要求）

**示例：** TDD、verification-before-completion、designing-before-coding

**测试方法：**
- 学术问题：他们理解规则吗？
- 压力场景：他们在压力下遵循吗？
- 多种压力组合：时间 + 沉没成本 + 疲劳
- 识别合理化借口并添加显式计数器

**成功标准：** 代理在最大压力下遵循规则

### 技术技能（操作指南）

**示例：** condition-based-waiting、root-cause-tracing、defensive-programming

**测试方法：**
- 应用场景：他们能正确应用技术吗？
- 变化场景：他们处理边缘情况吗？
- 缺失信息测试：指令有差距吗？

**成功标准：** 代理成功将技术应用于新场景

### 模式技能（心智模型）

**示例：** reducing-complexity、information-hiding 概念

**测试方法：**
- 识别场景：他们识别何时适用吗？
- 应用场景：他们能使用心智模型吗？
- 反例：他们知道何时不应用吗？

**成功标准：** 代理正确识别何时/如何应用模式

### 参考技能（文档/API）

**示例：** API 文档、命令参考、库指南

**测试方法：**
- 检索场景：他们能找到正确的信息吗？
- 应用场景：他们能正确使用找到的内容吗？
- 差距测试：常见用例覆盖了吗？

**成功标准：** 代理找到并正确应用参考信息

## 跳过测试的常见合理化借口

| 借口 | 现实 |
|------|------|
| "技能显然很清楚" | 对你清楚 ≠ 对其他代理清楚。测试它。 |
| "这只是参考" | 参考可能有差距、不清楚的部分。测试检索。 |
| "测试太过度了" | 未经测试的技能有问题。总是如此。15 分钟测试节省数小时。 |
| "如果出现问题我会测试" | 问题 = 代理无法使用技能。部署前测试。 |
| "测试太乏味" | 测试比在生产中调试坏技能不那么乏味。 |
| "我相信它很好" | 过度自信保证有问题。无论如何测试。 |
| "学术审查就足够了" | 阅读 ≠ 使用。测试应用场景。 |
| "没时间测试" | 部署未经测试的技能以后修复它浪费更多时间。 |

**所有这些都意味着：部署前测试。无例外。**

## 使技能对合理化借口防弹

强制纪律的技能（如 TDD）需要抵抗合理化。代理很聪明，会在压力下找到漏洞。

### 显式关闭每个漏洞

不要只陈述规则——禁止特定的变通方法：

<坏>
```markdown
测试前写代码？删除它。
```
</坏>

<好>
```markdown
测试前写代码？删除它。重新开始。

**无例外：**
- 不要将其保留为"参考"
- 不要在编写测试时"适应"它
- 不要看它
- 删除意味着删除
```
</好>

### 解决"精神 vs 字面"参数

在早期添加基础原则：

```markdown
**违反规则的字面就是违反规则的精神。**
```

这切断了整类"我遵循精神"的合理化借口。

### 构建合理化借口表

从基线测试中捕获合理化借口（见下面的测试部分）。代理制造的每个借口都进入表格：

```markdown
| 借口 | 现实 |
|------|------|
| "太简单无法测试" | 简单的代码会坏。测试需要 30 秒。 |
| "我稍后会测试" | 测试立即通过证明不了什么。 |
| "测试后达到相同目标" | 测试后 = "这是做什么？" 测试前 = "这应该做什么？" |
```

### 创建红旗列表

使代理容易在合理化时自检：

```markdown
## 红旗 - 停止并重新开始

- 测试前写代码
- "我已经手动测试了"
- "测试后达到相同目的"
- "这是关于精神而非仪式"
- "这不同，因为..."

**所有这些都意味着：删除代码。使用 TDD 重新开始。**
```

### 为违规症状更新 CSO

添加到描述：何时即将违规的症状：

```yaml
description: 实现任何功能或错误修复时，在编写实现代码之前使用
```

## 技能的 RED-GREEN-REFACTOR

遵循 TDD 循环：

### RED：编写失败测试（基线）

在没有技能的情况下使用子代理运行压力场景。记录确切行为：
- 他们做了什么选择？
- 他们使用了什么合理化借口（逐字）？
- 哪些压力触发了违规？

这是"观察测试失败"——你必须看到代理在编写技能前的自然行为。

### GREEN：编写最小技能

编写针对那些特定合理化借口的技能。不要为假设情况添加额外内容。

使用技能运行相同场景。代理现在应该遵循规范。

### REFACTOR：关闭漏洞

代理找到新的合理化借口？添加显式计数器。重新测试直到防弹。

## 反模式

### ❌ 叙述示例
"在 2025-10-03 会话中，我们发现空的 projectDir 导致..."
**为何不好：** 太具体，不可重用

### ❌ 多语言稀释
example-js.js、example-py.py、example-go.go
**为何不好：** 质量平庸，维护负担

### ❌ 流程图中的代码
```dot
step1 [label="import fs"];
step2 [label="read file"];
```
**为何不好：** 无法复制粘贴，难以阅读

### ❌ 通用标签
helper1、helper2、step3、pattern4
**为何不好：** 标签应具有语义意义

## 停止：在进入下一个技能之前

**编写任何技能后，你必须停止并完成部署过程。**

**不要：**
- 批量创建多个技能而不测试每个
- 在当前技能验证之前移动到下一个
- 跳过测试因为"批处理更高效"

**下面的部署清单对每个技能都是强制性的。**

部署未经测试的技能 = 部署未经测试的代码。这违反质量标准。

## 技能创建清单（TDD 适配）

**RED 阶段 - 编写失败测试：**
- [ ] 创建压力场景（纪律技能 3+ 种组合压力）
- [ ] 没有技能的情况下运行场景 - 逐字记录基线行为
- [ ] 识别合理化借口/失败中的模式

**GREEN 阶段 - 编写最小技能：**
- [ ] 名称仅使用字母、数字、连字符（无括号/特殊字符）
- [ ] YAML frontmatter 仅包含名称和描述（最多 1024 字符）
- [ ] 描述以 "Use when..." 或 "使用...时使用" 开头并包含具体触发器/症状
- [ ] 描述用第三人称编写
- [ ] 贯穿始终用于搜索的关键词（错误、症状、工具）
- [ ] 包含核心原则的清晰概述
- [ ] 解决 RED 中识别的特定基线失败
- [ ] 代码内联或链接到单独文件
- [ ] 一个优秀的示例（非多语言）
- [ ] 使用技能运行场景 - 验证代理现在遵循规范

**REFACTOR 阶段 - 关闭漏洞：**
- [ ] 从测试中识别新的合理化借口
- [ ] 添加显式计数器（如果是纪律技能）
- [ ] 从所有测试迭代构建合理化借口表
- [ ] 创建红旗列表
- [ ] 重新测试直到防弹

**质量检查：**
- [ ] 仅当决策不明显时使用小型流程图
- [ ] 快速参考表
- [ ] 常见错误部分
- [ ] 无叙述讲故事
- [ ] 仅在工具或重型参考时使用支持文件

## 发现工作流

未来的 Claude 如何找到你的技能：

1. **遇到问题**（"测试不稳定"）
2. **找到技能**（描述匹配）
3. **扫描概述**（这相关吗？）
4. **阅读模式**（快速参考表）
5. **加载示例**（仅在实现时）

**优化此流程** - 尽早并经常放置可搜索的术语。

## 总结

**编写技能就是用于过程文档的 TDD。**

相同的铁律：没有失败的测试就没有技能。
相同的循环：RED（基线）→ GREEN（编写技能）→ REFACTOR（关闭漏洞）。
相同的好处：更好的质量、更少的意外、防弹的结果。

如果你对代码遵循 TDD，对技能也遵循 TDD。这是应用于文档的相同纪律。
